// backend/routes/quests.js
// Mount at app.use('/api/quests', require('./routes/quests'));

const express = require('express');
const router = express.Router();
const db = require('../db');
const { requireAuth } = require('../authMiddleware');

// GET /api/quests
router.get('/', async (req, res) => {
  try {
    const q = await db.query('SELECT * FROM quests ORDER BY id');
    res.json({ success: true, quests: q.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false });
  }
});

// POST /api/quests/:id/complete -> mark quest as complete and apply reward if any
router.post('/:id/complete', requireAuth, async (req, res) => {
  try {
    const userId = req.user.id;
    const questId = req.params.id;
    // mark user_quests
    await db.query(`
      INSERT INTO user_quests (user_id, quest_id, status, completed_at)
      VALUES ($1,$2,'completed',now())
      ON CONFLICT (user_id, quest_id) DO UPDATE SET status='completed', completed_at=now()
    `, [userId, questId]);

    // apply reward if quest reward grants trait/achievement
    const questQ = await db.query('SELECT reward FROM quests WHERE id = $1', [questId]);
    if (questQ.rows[0] && questQ.rows[0].reward) {
      const reward = questQ.rows[0].reward;
      if (reward.type === 'trait' && reward.trait_id) {
        await db.query('INSERT INTO user_avatar_traits (user_id, trait_id) VALUES ($1,$2) ON CONFLICT DO NOTHING', [userId, reward.trait_id]);
      }
      if (reward.type === 'achievement' && reward.achievement_key) {
        const ach = await db.query('SELECT id FROM achievements WHERE key = $1 LIMIT 1', [reward.achievement_key]);
        if (ach.rows.length) {
          await db.query('INSERT INTO user_achievements (user_id, achievement_id) VALUES ($1,$2) ON CONFLICT DO NOTHING', [userId, ach.rows[0].id]);
        }
      }
    }

    res.json({ success: true });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false });
  }
});

module.exports = router;
